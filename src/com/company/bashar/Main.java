package com.company.bashar;

import java.io.*;
import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.util.*;


public class Main {

    private static ArrayList<Integer> result = new ArrayList<>();

    public static void main(String args[]) throws NoSuchAlgorithmException
    {
        final int numberOfTransactionsToTest = 6;

        //parse CSV file and store all the transactions in a TransactionDataModel ArrayList
        OpenCSVReader.parseCSVFile();

        //print the transactions for log Purpose
//        printTransactions(OpenCSVReader.listOfTransactions);

        ArrayList<TransactionDataModel> transactions =
                geRandomTransactions(OpenCSVReader.listOfTransactions, numberOfTransactionsToTest);

        ArrayList<SpanningTreeDataModel> pointsOfTransactions = getPointsOfTransactions(transactions);
//        for (SpanningTreeDataModel item: pointsOfTransactions) {
//            System.out.println(item.getXCoordinate());
//        }

        //sort the array pointsOfTransactions by the x value
        //Therefore, the starting point is always the point with minimum value of x
        Collections.sort(pointsOfTransactions, new Comparator<SpanningTreeDataModel>() {
            @Override
            public int compare(SpanningTreeDataModel o1, SpanningTreeDataModel o2) {
                return Double.compare(o1.getXCoordinate(), o2.getXCoordinate());
            }
        });

//        System.out.println("Sorted order: ");
//        for (SpanningTreeDataModel item: pointsOfTransactions) {
//            System.out.println(item.getXCoordinate());
//        }

        //create an adjacency matrix of all the points connected with each other by the euclidean distance between them
        double graph[][] = new double[numberOfTransactionsToTest][numberOfTransactionsToTest];

        for(int i = 0; i < numberOfTransactionsToTest; i++) {
            for(int j = 0; j < numberOfTransactionsToTest; j++) {
                graph[i][j] = EuclideanDistanceCalculator.calculate(pointsOfTransactions.get(i), pointsOfTransactions.get(j));
            }
        }

        //print the adjacency for log purpose
        for(int i = 0; i < numberOfTransactionsToTest; i++) {
            for(int j = 0; j < numberOfTransactionsToTest; j++) {
                System.out.print(graph[i][j] + "  ");
            }
            System.out.println();
        }

        //apply prims algorithm to find a minimum spanning tree
        PrimsAlgorithmMST mst = new PrimsAlgorithmMST();
        mst.primMST(graph);

        //print MST graph for log purpose
        for(int i = 0; i < numberOfTransactionsToTest; i++) {
            for(int j = 0; j < numberOfTransactionsToTest; j++) {
                System.out.print(graph[i][j] + "  ");
            }
            System.out.println();
        }


    }

        //select random transactions without repetition
    private static ArrayList<TransactionDataModel> geRandomTransactions(ArrayList<TransactionDataModel> list,
                                                                        int totalItems)
    {
        Random rand = new Random();

        // create a temporary list for storing
        // selected element
        ArrayList<TransactionDataModel> selectedList = new ArrayList<>();

        for (int i = 0; i < totalItems; i++) {

            // take a raundom index between 0 to size of given List
            int randomIndex = rand.nextInt(list.size() - 1);

            // add element in temporary list
            selectedList.add(list.get(randomIndex));

            // Remove selected element from orginal list
            list.remove(randomIndex);
        }
        return selectedList;
    }

    private static ArrayList<SpanningTreeDataModel> getPointsOfTransactions (ArrayList<TransactionDataModel> transactionList) {
        ArrayList<SpanningTreeDataModel> pointList = new ArrayList<>();

        for(TransactionDataModel item : transactionList) {
            String concatenatedString = item.buildStringFromTransactions();

            String hashValue = MdFiveHashFunction.getMd5(concatenatedString);
//            System.out.println("Your HashCode length: " + hashValue.length());
//            System.out.println("Your HashCode Generated by MD5 is: " + hashValue);

            String xHashValue = hashValue.substring(0, 16);
            String yHashValue = hashValue.substring(16);

            BigInteger xPoint = new BigInteger(xHashValue, 16);
            String x = xPoint.toString(10);
            double xValue = Double.parseDouble(x);

            BigInteger yPoint = new BigInteger(yHashValue, 16);
            String y = yPoint.toString(10);
            double yValue = Double.parseDouble(y);

            pointList.add(new SpanningTreeDataModel(xValue, yValue));
        }

        System.out.println("Total list of points: " + pointList.size());
        return pointList;
    }

    private static void treeTraversal(int root) {
        
    }


    private static void appendResultToFile(String fileName,
                                       String str)
    {
        try {

            // Open given file in append mode.
            BufferedWriter out = new BufferedWriter(
                    new FileWriter(fileName, true));
            out.write(str);
            out.close();
        }
        catch (IOException e) {
            System.out.println("exception occoured" + e);
        }
    }

    private static void removeOutputFileContents() {
        try {
            PrintWriter output = new PrintWriter("output.txt");
            output.println("");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


