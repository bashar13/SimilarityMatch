package com.company.bashar;

import java.io.*;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.util.*;


public class Main {

    //records the sequence of points after traversing the MST
    private static ArrayList<Integer> result = new ArrayList<>();


    public static void main(String args[]) throws NoSuchAlgorithmException
    {
        int numberOfTransactionsToTest = 6;
        //parse CSV file and store all the transactions in a TransactionDataModel ArrayList
        OpenCSVReader.parseCSVFile();

        //print the transactions for log Purpose
//        printTransactions(OpenCSVReader.listOfTransactions);

        ArrayList<TransactionDataModel> transactions =
                geRandomTransactions(OpenCSVReader.listOfTransactions, numberOfTransactionsToTest);
        ArrayList<SpanningTreeDataModel> pointsOfTransactions = new ArrayList<>();

        for (TransactionDataModel transaction: transactions) {
            pointsOfTransactions.add(getPointsOfTransactions(transaction));
        }

//        for (SpanningTreeDataModel item: pointsOfTransactions) {
//            System.out.println(item.getXCoordinate());
//        }

        //sort the array pointsOfTransactions by the x value
        //Therefore, the starting point is always the point with minimum value of x
        Collections.sort(pointsOfTransactions, new Comparator<SpanningTreeDataModel>() {
            @Override
            public int compare(SpanningTreeDataModel o1, SpanningTreeDataModel o2) {
                return Double.compare(o1.getXCoordinate(), o2.getXCoordinate());
            }
        });

        System.out.println("Sorted order: ");
        for (SpanningTreeDataModel item: pointsOfTransactions) {
            System.out.println("x: " + item.getXCoordinate() + " y: " + item.getYCoordinate());
        }

        removeOutputFileContents();
        //create an adjacency matrix of all the points connected with each other by the euclidean distance between them
        double graph[][] = new double[numberOfTransactionsToTest][numberOfTransactionsToTest];
        appendResultToFile("output.txt", "Main set of transaction");
        mstTraversalForPointsOfTransactions(graph, pointsOfTransactions, numberOfTransactionsToTest);

        //add a new transaction to transaction list and remove one
        pointsOfTransactions.remove(pointsOfTransactions.size()-1);
        appendResultToFile("output.txt", "Main set of transaction + 1");
        Random rand = new Random();
        int randomPickIndex = rand.nextInt(OpenCSVReader.listOfTransactions.size() - 1);
        TransactionDataModel pickedTransaction = OpenCSVReader.listOfTransactions.get(randomPickIndex);
        pointsOfTransactions.add(getPointsOfTransactions(pickedTransaction));

        mstTraversalForPointsOfTransactions(graph, pointsOfTransactions, numberOfTransactionsToTest);



    }

    //select random transactions without repetition
    private static ArrayList<TransactionDataModel> geRandomTransactions(ArrayList<TransactionDataModel> list,
                                                                        int totalItems)
    {
        Random rand = new Random();

        // create a temporary list for storing
        // selected element
        ArrayList<TransactionDataModel> selectedList = new ArrayList<>();

        for (int i = 0; i < totalItems; i++) {

            // take a raundom index between 0 to size of given List
            int randomIndex = rand.nextInt(list.size() - 1);

            // add element in temporary list
            selectedList.add(list.get(randomIndex));

            // Remove selected element from orginal list
            list.remove(randomIndex);
        }
        return selectedList;
    }

    /*
    creates hash value for a given transaction and represents as a (x,y) point
     */
    private static SpanningTreeDataModel getPointsOfTransactions (TransactionDataModel transaction) {


        String concatenatedString = transaction.buildStringFromTransactions();

        String hashValue = MdFiveHashFunction.getMd5(concatenatedString);
//            System.out.println("Your HashCode length: " + hashValue.length());
//            System.out.println("Your HashCode Generated by MD5 is: " + hashValue);

        String xHashValue = hashValue.substring(0, 16);
        String yHashValue = hashValue.substring(16);

        BigInteger xPoint = new BigInteger(xHashValue, 16);
        String x = xPoint.toString(10);
        double xValue = Double.parseDouble(x);

        BigInteger yPoint = new BigInteger(yHashValue, 16);
        String y = yPoint.toString(10);
        double yValue = Double.parseDouble(y);

        SpanningTreeDataModel spanningTreeDataModel = new SpanningTreeDataModel(xValue, yValue);

        return spanningTreeDataModel;
    }

    /*
    does the steps 4-7 mentioned in the README.md file
     */
    private static void mstTraversalForPointsOfTransactions(double graph[][], ArrayList<SpanningTreeDataModel> pointsOfTransactions, int total) {
        for(int i = 0; i < total; i++) {
            for(int j = 0; j < total; j++) {
                graph[i][j] = EuclideanDistanceCalculator.calculate(pointsOfTransactions.get(i), pointsOfTransactions.get(j));
            }
        }

        //print the adjacency for log purpose
        for(int i = 0; i < total; i++) {
            for(int j = 0; j < total; j++) {
                System.out.print(graph[i][j] + "  ");
            }
            System.out.println();
        }

        //apply prims algorithm to find a minimum spanning tree
        PrimsAlgorithmMST mst = new PrimsAlgorithmMST();
        mst.primMST(graph);

        //print MST graph for log purpose
        for(int i = 0; i < total; i++) {
            for(int j = 0; j < total; j++) {
                System.out.print(graph[i][j] + "  ");
            }
            System.out.println();
        }

        treeTraversal(0, graph, pointsOfTransactions, total);
//        for(int point: result) {
//            System.out.println(point);
//        }


        String resultString = createStringForTheResultArraybyLabel(pointsOfTransactions);
        appendResultToFile("output.txt", resultString);
    }

    /*
    Traverses the MST in post order
    output: populates the result array in traversing order
     */
    private static void treeTraversal(int root, double graph[][], ArrayList<SpanningTreeDataModel> pointsOfTransactions, int total) {
        ArrayList<Integer> childList = new ArrayList<>();
        for(int i=0; i<total; i++) {
            if (graph[root][i] == 1.0) {
                childList.add(i);
            }
        }
        if(childList.size() > 1) {
            sortChildrens(childList, pointsOfTransactions);
        }
        for(int child: childList) {
            treeTraversal(child, graph, pointsOfTransactions, total);
        }
        result.add(root);
    }

    /*
    sorts the child nodes(points) of a parent node (point) by their y value or x value (if y value is equal)
     */
    private static void sortChildrens(ArrayList<Integer> childList, ArrayList<SpanningTreeDataModel> pointsOfTransactions) {
        int size = childList.size();
        for(int i=0; i < size-1; i++) {
            for(int j=0; j < size-i-1; j++) {
                if(pointsOfTransactions.get(childList.get(j)).getYCoordinate() > pointsOfTransactions.get(childList.get(j+1)).getYCoordinate()) {
                    swapElements(childList, j, j+1);
                } else if (pointsOfTransactions.get(childList.get(j)).getYCoordinate() == pointsOfTransactions.get(childList.get(j+1)).getYCoordinate()) {
                    if (pointsOfTransactions.get(childList.get(j)).getXCoordinate() > pointsOfTransactions.get(childList.get(j+1)).getXCoordinate()) {
                        swapElements(childList, j, j+1);
                    }
                }
            }
        }
    }

    private static void swapElements(ArrayList<Integer> childList, int p, int q) {

        int temp = childList.get(p);
        childList.set(p, childList.get(q));
        childList.set(q, temp);
    }

    /*
    creates a string a sequential labels of the points generated after traversing the MST
    Parameters: pointsOfTransactions- ArrayList of point objects participated in generating the MST
    Returns: String - string by concatenating the labels of the points in result array
     */
    private static String createStringForTheResultArraybyLabel(ArrayList<SpanningTreeDataModel> pointsOfTransactions) {

        StringBuilder concatenateStrings = new StringBuilder();
        for (int i=0; i<result.size(); i++) {
            concatenateStrings.append(pointsOfTransactions.get(result.get(i)).getPointLabel());
            if(i != result.size() - 1) {
                concatenateStrings.append(", ");
            }
        }
        result.clear();
        return concatenateStrings.toString();
    }

    /*
    writes the result in the output.txt after each execution
     */
    private static void appendResultToFile(String fileName,
                                       String str)
    {
        try {

            // Open given file in append mode.
            BufferedWriter out = new BufferedWriter(
                    new FileWriter(fileName, true));
            out.write(str + "\n");
            out.close();
        }
        catch (IOException e) {
            System.out.println("exception occoured" + e);
        }
    }

    /*
    deletes the contents of output.txt before each execution
     */
    private static void removeOutputFileContents() {
        try {
            PrintWriter output = new PrintWriter("output.txt");
            output.println("");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


